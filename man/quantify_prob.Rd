% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/quantify_prob.R
\name{quantify_prob}
\alias{quantify_prob}
\title{quantify_prob() Function}
\usage{
quantify_prob(f, probs, truth_table = NULL)
}
\arguments{
\item{f}{(Required) Function outputted by \code{formulate()}, with one argument per
basic event. Used to identify event names and, if \code{truth_table} is not
supplied, to generate the truth table via \code{calculate(f)}.}

\item{probs}{(Required) Failure probabilities for each basic event. Can be a
single vector or list (one scenario), or a data frame or matrix with one
row per scenario and columns for each basic event (names must match
\code{formalArgs(f)}). Unnamed vectors are interpreted in
\code{formalArgs(f)} order. Values should be in \code{[0, 1]}.}

\item{truth_table}{(Optional) Data frame with one column per basic event (0/1)
and an \code{outcome} column (1 = system failure, 0 = no failure). If
provided, the truth table is not recomputed (useful when \code{calculate()}
was already run).}
}
\value{
A single numeric value, or if \code{probs} has multiple rows (one per
scenario), a numeric vector of top-event failure probabilities (one per
scenario, same order as rows of \code{probs}).
}
\description{
Computes the top event failure probability from a fault tree when given
basic event failure probabilities. Assumes independent basic events; uses
the full truth table to sum probabilities over all failure combinations.
}
\details{
The top event probability is computed exactly via the complete truth
table: for each of the 2^n combinations of basic event states, the
probability of that combination is the product of \code{probs[e]} for events
that occur (1) and \code{1 - probs[e]} for events that do not (0). The
function sums these probabilities over all combinations where
\code{outcome == 1}. This is exact for independent basic events but has
complexity O(2^n); for trees with many basic events, consider using minimal
cut set approximations elsewhere. When \code{probs} has multiple rows, the
truth table is computed once and all scenarios are evaluated in one pass.
}
\examples{
library(tidyverse)
library(tidyfault)
library(QCA)
data("fakenodes")
data("fakeedges")

f <- curate(nodes = fakenodes, edges = fakeedges) \%>\%
  equate() \%>\%
  formulate()
# Pipe-friendly: probability vector in event order (e.g. A, B, C, D)
curate(nodes = fakenodes, edges = fakeedges) \%>\%
  equate() \%>\%
  formulate() \%>\%
  quantify_prob(c(0.1, 0.2, 0.05, 0.15))

# Named probs (names must match event names in the tree)
probs <- setNames(c(0.1, 0.2, 0.05, 0.15), formalArgs(f))
f \%>\% quantify_prob(probs)

# Reuse an existing truth table to avoid recomputing
tt <- calculate(f)
f \%>\% quantify_prob(probs, truth_table = tt)

# Many scenarios at once (vectorized): pass a data frame, one row per scenario
probs_df <- as.data.frame(replicate(4, runif(1000), simplify = FALSE))
names(probs_df) <- formalArgs(f)
f \%>\% quantify_prob(probs_df, truth_table = tt)  # length-1000 vector
}
\seealso{
\code{\link{formulate}} for creating the function from a boolean
equation, \code{\link{calculate}} for generating the truth table,
\code{\link{quantify}} for evaluating whether the top event occurs given
binary (0/1) basic event states. The result matches the FaultTree package when
the same tree is built and \code{ftree.calc(DF, use.bdd = TRUE)} is used
(BDD accounts for repeated basic events; gate-by-gate with \code{use.bdd = FALSE}
does not).
}
\keyword{fault}
\keyword{probability}
\keyword{quantification}
\keyword{tree}
