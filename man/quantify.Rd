% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/quantify.R
\name{quantify}
\alias{quantify}
\title{quantify() Function}
\usage{
quantify(f, scenarios)
}
\arguments{
\item{f}{(Required) Function from \code{formulate()}, with one argument per
basic event. Used to identify event names and to evaluate the fault tree.}

\item{scenarios}{(Required) Either a tibble/data frame with one column per
basic event (names from \code{formalArgs(f)}), or a single vector/list.
A single scenario can be an unnamed vector in \code{formalArgs(f)} order
(e.g. \code{c(T, T, T, F)} or \code{c(1, 1, 0, 1)}), or a named vector/list.
Values are logical (TRUE/FALSE) or numeric (0/1).}
}
\value{
If \code{scenarios} is a data frame: a tibble with the same columns
plus an \code{outcome} column (logical: TRUE = system failure, FALSE = no
failure). If \code{scenarios} is a named vector or list: a single logical
(TRUE/FALSE).
}
\description{
Evaluates whether the top event occurs (system fails) when given whether each
basic event occurs or not. Inputs are binary: each event is 0 (did not occur)
or 1 (occurred). No probabilitiesâ€”deterministic evaluation only.
}
\details{
No probabilities are used; the function evaluates the fault tree
on the given event states. Outcome is TRUE when \code{f(...) >= 1} (system
failure). Logical and 0/1 inputs are coerced to 0/1 internally to match
\code{calculate()} behavior. When \code{scenarios} is a data frame,
evaluation is vectorized: \code{f} is called once with vector columns
(one element per row), so many scenarios are handled efficiently.
}
\examples{
library(tidyverse)
library(tidyfault)
library(QCA)
data("fakenodes")
data("fakeedges")

# Pipe-friendly: single scenario in event order (e.g. A, B, C, D)
curate(nodes = fakenodes, edges = fakeedges) \%>\%
  equate() \%>\%
  formulate() \%>\%
  quantify(c(T, T, T, F))

f <- curate(nodes = fakenodes, edges = fakeedges) \%>\%
  equate() \%>\%
  formulate()

# Single scenario: unnamed vector in event order
f \%>\% quantify(c(TRUE, FALSE, TRUE, FALSE))

# Single scenario: named vector (logical or 0/1)
one_scenario <- setNames(c(TRUE, FALSE, TRUE, FALSE), formalArgs(f))
f \%>\% quantify(one_scenario)

# Tibble of scenarios: add outcome column (vectorized, one call to f for all rows)
scenarios_tbl <- tibble(
  A = c(1L, 0L, 1L),
  B = c(0L, 1L, 1L),
  C = c(1L, 0L, 0L),
  D = c(0L, 1L, 1L)
)
f \%>\% quantify(scenarios_tbl)
}
\seealso{
\code{\link{formulate}} for creating the function, \code{\link{calculate}}
for the full truth table, \code{\link{quantify_prob}} for top event failure
probability given basic event probabilities.
}
\keyword{binary}
\keyword{evaluation}
\keyword{fault}
\keyword{tree}
